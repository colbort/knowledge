# Go 结构体字节对齐（通俗易懂版）

> 把“对齐”理解成：**每个字段要站到它喜欢的刻度线**；不在刻度线上就**垫空位**；最后**总长度也要凑整**。

---

## 一、三句话讲清楚

1. **每个字段要从“合适的位置”开头**  
   这个“合适的位置”是它自己的对齐步长（alignment）。  
   例：`int32` 喜欢从 4 的倍数地址开始，`int64` 喜欢从 8 的倍数地址开始。

2. **不合适就“垫点儿棉花”（填充字节）**  
   若上一个字段结束的位置不满足下一个字段的对齐要求，编译器会在中间自动插入若干**填充字节**（padding）。

3. **整个结构体的大小也要“整整齐齐”**  
   结构体总大小必须是**最大对齐值**的整数倍，所以**尾部**也可能再补一点填充。

---

## 二、尺子比喻（一眼就懂）

- 内存像一把从 0 开始的尺子：`0 1 2 3 4 5 6 7 8 ...`  
- `int32` 只能站在 `0,4,8,12...` 上；`int64` 只能站在 `0,8,16,24...` 上。  
- 如果轮到某个字段上台时，前一个字段没刚好停在它喜欢的刻度，就**垫几格空位**让它对齐。  
- 结构体结束时，如果总长度不是“最大步长”的倍数，也**在尾巴垫几格**补齐。

---

## 三、对比示例

```go
type Bad struct {
    A byte   // 1 字节，起于偏移 0
    B int64  // 需要 8 字节对齐 → 在 A 后面要垫 7 字节
    C int32  // 需要 4 字节对齐 → 紧跟 B 即可
}

// 典型布局：A[0] + padding(7) + B[8..15] + C[16..19] + 尾部补齐到 8 的倍数
// 典型总大小：24 字节（不是 1+8+4=13）
```

把顺序调整后：

```go
type Good struct {
    B int64  // 8 对齐
    C int32  // 4 对齐
    A byte   // 1 对齐（尾部可能再补一点）
}

// 典型总大小：16 字节，更紧凑
```

> 经验：**从大到小排（8 → 4 → 2 → 1），小字段抱团**，通常能显著减少 padding。

---

## 四、常见对齐值（64 位常见）

| 类型 | 大小 | 常见对齐值 |
|---|---:|---:|
| `bool`, `byte` | 1 | 1 |
| `int16`, `uint16` | 2 | 2 |
| `int32`, `float32` | 4 | 4 |
| `int64`, `uint64`, `float64`, `time.Time` | 8 | 8 |
| 指针、`uintptr` | 8 | 8 |
| 字符串/切片/map/chan/func（头部） | ~16 | 8 |

> 实际以 `unsafe.Alignof(v)` 为准；32 位平台指针是 4 字节，对齐也会不同。

---

## 五、并发与原子操作（对齐要特别当心）

- 在 **32 位**架构上，`atomic.*Uint64` **必须 8 字节对齐**；把 `uint64` 放在结构体**开头**或确保其偏移是 8 的倍数。  
- **伪共享**：并发写相邻字段会竞争同一 cache line。需要时给热点字段**填充到 64B**：
  ```go
  const cacheLine = 64
  type Counter struct {
      A uint64
      _ [cacheLine - 8]byte
      B uint64
      _ [cacheLine - 8]byte
  }
  ```

---

## 六、检查与优化

- **打印布局**：`unsafe.Sizeof/Alignof/Offsetof`。  
- **自动建议**：`go vet -fieldalignment ./...` 给出可优化的字段顺序。  
- **基准验证**：改布局后跑基准，观察 `allocs/op` 与吞吐。

---

## 七、序列化的提醒

Go **没有**像 C 的“紧凑打包”指令，**不要**把 struct 原样写到网络/磁盘。应使用：  
`encoding/binary`（明确字节序）、`json`/`protobuf`/`flatbuffers` 等协议库。

---

## 八、速记卡

- **规则**：字段按自己的对齐步长起始；不对齐就**自动补空**；总大小=最大对齐的倍数。  
- **做法**：**大到小排、指针和 64 位字段放前、小字段抱团**。  
- **工具**：`unsafe` 三件套 + `go vet -fieldalignment`。  
- **平台差异**：32/64 位对齐不同，以实际编译环境为准。
