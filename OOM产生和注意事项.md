# 🧠 OOM（Out Of Memory）是什么？

就是程序占用的内存超过系统/容器允许的上限，被操作系统直接"杀死"。

------------------------------------------------------------------------

# 🚨 一、什么情况会产生 OOM

## 1. 一次性读入过大的数据

常见情况： - `SELECT *` 查询大表，一次返回几百万行\
- `fs.readFile` / `ioutil.ReadFile` 读取超大文件\
- 构造超大 JSON / 字符串（几百 MB～几 GB）\
- 图片/视频处理时同时 decode 多个大文件

**特点：突然占满内存，几秒内崩溃。**

------------------------------------------------------------------------

## 2. 内存泄漏（GC 语言也会发生）

常见原因： - 全局变量、缓存 `map/list` 不断累积，没有删除\
- map key 不断变大，永远不清理\
- WebSocket/连接/定时器没有关闭\
- 回调/闭包引用大对象，导致 GC 无法回收

**特点：内存慢慢上涨，运行数小时/数天后 OOM。**

------------------------------------------------------------------------

## 3. 无上限的"池子 / 队列 / 缓存 / channel"

例如： - 内存队列无限 push\
- `chan` buffer 大且生产速度 \> 消费速度\
- 缓存无 TTL、无最大容量\
- 日志/消息队列只进不出

**特点：高负载下快速堆积。**

------------------------------------------------------------------------

## 4. 并发过多

-   Go 中无限制地 `go func()`\
-   Node/Java 同时启动过多大任务\
-   同时处理几千张图片/视频/任务

**特点：内存 + CPU 爆发式增长。**

------------------------------------------------------------------------

## 5. 容器限制过小

-   Docker/K8s 设置的 `memory limit` 太低\
-   稍微波动就被 cgroup OOMKilled

------------------------------------------------------------------------

# 🛠 二、开发阶段如何避免 OOM

## 1. 所有集合/缓存/队列必须加"上限"

易发生 OOM 的结构： - `[]array` / `map` / `list` / 自定义队列

建议： - 限定最大长度（如最多 1000 条）\
- 缓存设置 TTL + 最大容量

✔ **宁可丢部分数据，不要让服务死掉。**

------------------------------------------------------------------------

## 2. 大数据必须分页 / 流式 / 分块处理

适用场景： - DB 查询\
- 导出 CSV/Excel\
- 文件处理\
- 大 JSON 构造

避免一口吞。

------------------------------------------------------------------------

## 3. 避免隐形引用，确保 GC 能回收

要注意： - 不要把数据长期挂在全局变量上\
- 处理完要从 `map/slice` 删除\
- 大对象用完可置 nil（针对长期生命周期 struct）

------------------------------------------------------------------------

## 4. 控制并发，不要无脑开 goroutine

建议： - Go 用 worker pool 或 semaphore\
- CPU 密集任务限流\
- 外部请求控制最大同时处理量

------------------------------------------------------------------------

## 5. 在开发阶段就做内存测试

### Go：

-   使用 `pprof` 检查 heap/goroutine\
-   或打印 `runtime.ReadMemStats`

### Node/其他语言：

-   使用 DevTools / profiler\
-   简单压测脚本观察内存曲线

✔ **开发环境点两下接口 ≠ 实际运行环境**\
必须压几分钟看内存是否持续上涨。

------------------------------------------------------------------------

# 🏭 三、线上如何降低 OOM 风险

## 1. 设置进程可使用的最大内存

-   Docker/K8s 配 `memory limit`\
-   保留 buffer，例如实际占用 300MB，就给 512MB

------------------------------------------------------------------------

## 2. 加保护机制

-   请求体大小限制\
-   接口最大查询条数\
-   重任务批量执行或进入队列\
-   控制队列消费者数量

------------------------------------------------------------------------

## 3. 加监控与告警

监控项： - 进程（RSS）内存\
- GC 频率 / 停顿\
- Goroutine 数\
- OOMKilled 次数\
- 重启次数

------------------------------------------------------------------------

# ✔ 四、自查 Checklist（开发时必过一遍）

1.  有没有无限增长的 `map/list/chan/cache`？\
2.  有没有一次性读取大量数据或大文件？\
3.  有没有无限制的 `go func()` 或高并发？\
4.  用完的数据是否被全局变量/闭包引用？\
5.  是否做过简单压测 + 查看内存曲线？
