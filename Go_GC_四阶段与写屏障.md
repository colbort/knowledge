# Go GC：四阶段串联与“插入写屏障”详解（面试/实战版）

> 目标：把 **四个阶段** 串起来讲清楚 + **写屏障** 为什么、何时开启/关闭、到底拦了什么。基于 Go 1.19–1.22 的实现常识。

---

## 一、总览：四阶段时间线（两处短 STW）

```
时间 ─────────────────────────────────────────────────────────────────────────────────────────────>

┌──────────────┐    ┌────────────────────────── 并发标记（写屏障 ON） ───────────────────────────┐   ┌───────────────┐    ┌─────────────── 并发清扫 ────────────────┐
│ ① MarkStart  │ →  │ ② 并发标记：根入灰 → 扫描灰集→置黑；Mutator 正常跑 + Mark Assist + 抢占    │ → │ ③ MarkEnd     │ → │ ④ Sweep：按 span 清理白对象；惰性/后台  │
│ (短 STW)     │    │   (Insertion Write Barrier 保证黑不指向白)                                 │   │ (短 STW)      │    │   分配时可顺带清扫                      │
│ 开启写屏障   │    └────────────────────────────────────────────────────────────────────────────┘   │ 关闭写屏障     │    └──────────────────────────────────────┘
└──────────────┘                                                                                      └───────────────┘
```

- **仅在 ② 并发标记期间**开启写屏障；① 开启，③ 关闭。
- 两次 **STW 都很短**：① 稳定根/开启标记；③ 冲刷灰队列、重扫栈、终止标记。

---

## 二、四阶段串联（每步具体做什么、为什么）

### ① Mark Start（短 STW）
- **做什么**：
  - 结束上轮清扫收尾；
  - **扫描根并建立快照**（全局、寄存器、各 goroutine 栈根）；
  - **开启写屏障**（仅对“堆指针写入”生效）；启动并发标记者；恢复世界。
- **为什么**：需要一个一致的起点，并确保**从现在起 Mutator 的新连接不会漏标**。

### ② 并发标记（写屏障 ON）
- **做什么**：
  - 三色法：白(未见)→灰(待扫)→黑(已扫)；GC worker 并发扫描灰集；
  - Mutator 正常执行；**每次向堆写入指针触发写屏障**；
  - **Mark Assist**：分配端按比例协助扫描，避免 GC 落后；
  - Pacer 依据 `heapGoal = live * (1 + GOGC/100)` 动态节流。
- **为什么**：在并发状态下完成“可达集”收敛为黑。写屏障保证“黑不指向白”。

### ③ Mark End（短 STW）
- **做什么**：
  - **冲刷所有灰队列**，确保灰集清空；
  - **重扫各 goroutine 栈**（因为栈写通常不走屏障）；
  - 统计 `live`，**关闭写屏障**，终止标记。  
- **为什么**：补齐“栈更新”遗漏，形成最终一致的黑集。

### ④ 并发清扫（Sweep）
- **做什么**：
  - 按 span 回收白对象，放回自由列表；后台线程 + 惰性清扫（分配时触发）；
  - 直到清扫完毕，等待下一次 ①。  
- **为什么**：回收不可达对象；并发/惰性降低停顿。

---

## 三、插入写屏障（Insertion Write Barrier）讲透

### 1) 为什么需要写屏障
- 并发标记时，Mutator 可能把**白对象**挂到**黑对象**下面（黑→白），导致**漏标**。

### 2) Go 采用“插入屏障（Dijkstra）”
- **规则**：在标记期，每次向**堆**写入**指针**时，**把“新写入的对象”立即染成灰**（入标记队列）。
- **效果**：即使它被挂到一个已扫描的黑对象下，也不会漏标。

### 3) 伪代码（简化）
```go
// 写 *slot = new 时（仅在标记期且 new 指向堆对象才触发）
if gcphase == Marking && isHeapPointer(new) {
    shade(new)  // 将 new 所指对象入灰队列，稍后由 GC worker 扫描
}
*slot = new
```

> 注：为性能，写屏障事件会先写入每 P 的 **wbbuf**（写屏障缓冲），由 GC 工作者批量取走扫描，减少同步成本。

### 4) 为什么 ③ 还要短 STW 重新扫栈？
- 栈上写通常**不插屏障**（避免过大开销）→ 需要在 ①/③ 的 STW 里对各栈做**精准扫描**兜底，确保栈上的新指针不漏。

---

## 四、Mark Assist：为何“分配变慢”
- 在 ② 并发标记期，如果分配过快，GC worker 跟不上，**分配路径**会被要求**先完成一定量的标记工作**（按分配字节数扣“标记债”）。
- 体感：高分配速率场景下，**分配时延上升**；优化方向：**减少热点分配**、复用对象、让对象变为 **noscan**（无指针）。

---

## 五、触发与节流（pacer）
- 触发：到达 `heapGoal`（由上轮 `live` 与 `GOGC` 计算）、或 `runtime.GC()` 强制、或 1.19+ **`GOMEMLIMIT`** 软上限压制。  
- pacer 会动态调整 GC 速率与 assist 比例，使得在 `heapGoal` 前完成标记。

---

## 六、与分配器的衔接（为什么小对象快、大对象慢）
- 分配器层级：`mcache(每P)` → `mcentral(全局每size class)` → `mheap`。  
- **小对象**按 size class 快速分配；**大对象(>32KB)** 直接走 `mheap`，更慢且更易触发 GC。  
- **noscan**（无指针）对象不需要扫描指针，标记更快。

---

## 七、gctrace 对照（看懂一次 GC）
示例（简化）
```
gc 56 @11.234s 0%: 0.7+3.4+0.3 ms clock, 3.1+0.9/2.0/1.0 ms cpu, 512->300->320 MB, 600 MB goal, 8 P
```
- `0.7`：① MarkStart STW；`3.4`：② 并发标记；`0.3`：③ MarkEnd STW。  
- `512->300->320 MB`：开始堆 → 存活集 → 结束堆（含碎片）；`600 MB goal`：heapGoal；`8 P`：GOMAXPROCS。

---

## 八、常见问答（考官爱问）
- **Q：GC 为什么要两次短 STW？**  
  **A**：① 稳定根并开启屏障；③ 冲刷灰队列并**重扫栈**（栈写无屏障），确保最终不漏标。

- **Q：写屏障到底拦了谁？**  
  **A**：只拦“**向堆写入的指针**”。把**被写入的对象**（而不是源对象）染灰。

- **Q：为什么分配会变慢？**  
  **A**：并发标记期触发 **Mark Assist**，分配端先“还 GC 的标记债”。

- **Q：如何降低 GC 压力？**  
  **A**：减少分配/缩小存活集、无指针对象（noscan）、池化、调 `GOGC`/`GOMEMLIMIT`。

---

## 九、面试 20 秒版
> “GC 四阶段：**①MarkStart(短STW, 开屏障)** → **②并发标记(写屏障ON, Mark Assist)** → **③MarkEnd(短STW, 冲刷灰队列并重扫栈, 关屏障)** → **④并发清扫**。  
> 插入写屏障采用 **Dijkstra**：标记期对**堆指针写**把**新指向对象**染灰，保证‘黑不指向白’；栈写无屏障，故在 ①/③ 的 STW 扫栈兜底。”

---

### 关键词：
`MarkStart/MarkEnd`、`Insertion Write Barrier`、`tri-color`、`Mark Assist`、`heapGoal`、`GOGC`、`GOMEMLIMIT`、`mcache/mcentral/mheap`、`noscan`、`STW`、`wbbuf`。
